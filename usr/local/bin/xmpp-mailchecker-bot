#!/usr/bin/env python2
# -*- coding: utf8 -*-

import sys, string, xmpp, os.path, poplib, imaplib, time, signal, os, hashlib, json, traceback, re, sqlite3
from email import parser
from email.header import decode_header
from threading import Thread, Lock

sys.path.append(os.path.abspath('/usr/local/lib/xmpp-mailchecker-bot/'))
import XMPPLogger, MailCheck


commands = {}
storage      = None
bot          = None
mailcheckers = None
config       = None
logger       = None

################################################  database ####################################################################
class DBStorage(object):

    def init(self, db_file):
	db_exists = os.path.exists(db_file)
	self.db = sqlite3.connect(db_file, check_same_thread = False)
	if not db_exists:
	    self.db.cursor().execute('CREATE TABLE records (jid VARCHAR(256), postbox VARCHAR(256), server VARCHAR(256), login VARCHAR(256), password VARCHAR(256))')
	    self.db.cursor().execute('CREATE TABLE messages (jid VARCHAR(256), postbox VARCHAR(256), message_hash VARCHAR(64))')
	    self.db.cursor().execute('create index records_index_jid on records (jid)')
	    self.db.cursor().execute('create index records_index on records (jid, postbox)')
	    self.db.cursor().execute('create index messages_index_jid on messages (jid)')
	    self.db.cursor().execute('create index messages_index on messages (jid, postbox)')
	    self.db.commit()
	
    def getRecord(self, jid, postbox):
	q = self.db.cursor()
	q.execute('select server, login, password from records where jid=? and postbox=?', (jid, postbox))
	for row in q:
	    return {'jid': jid, 'postbox': postbox, 'server': row[0], 'login': row[1], 'password': row[2]}
	    
    def getRecords(self, jid):
	q = self.db.cursor()
	q.execute('select postbox, server, login, password from records where jid=?', [jid])
	result=list()
	for row in q:
	    result.append({'jid': jid, 'postbox': row[0], 'server': row[1], 'login': row[2], 'password': row[3]})
	return result

    def getJids(self):
	q = self.db.cursor()
	q.execute('select distinct jid from records')
	result=list()
	for row in q:
	    result.append(row[0])
	return result

    def storeRecord(self, jid, postbox, server, login, password):
	self.db.cursor().execute('INSERT INTO records VALUES (?, ?, ?, ?, ?)', (jid, postbox, server, login, password))
	self.db.commit()
	
    def editRecord(self, jid, postbox, server, login, password):
	self.db.cursor().execute('update records set server=?, login=?, password=? wherejid=? and postbox=?)', (server, login, password, jid, postbox))
	self.db.commit()
	
    def removeRecord(self, jid, postbox):
	self.db.cursor().execute('delete from records where jid=? and postbox=?', (jid, postbox))
	self.db.commit()
	self.resetMessageHashes(jid, postbox)
	
    def checkMessageHashExists(self, jid, postbox, message_hash):
	q = self.db.cursor()
	q.execute('select count(*) from messages where jid=? and postbox=? and message_hash=?', (jid, postbox, message_hash))
	result = False
	for row in q:
	    if int(row[0]) > 0:
		result = True
	    else:
		self.db.cursor().execute('INSERT INTO messages VALUES (?, ?, ?)', (jid, postbox, message_hash))
		self.db.commit()
	    break
	return result

    def cleanMessageHashes(self, jid, postbox, hashes):
	q = self.db.cursor()
	q.execute('select message_hash from messages where jid=? and postbox=?', (jid, postbox))
	for row in q:
	    if row[0] not in hashes:
		self.db.cursor().execute('delete from messages where jid=? and postbox=? and message_hash=?', (jid, postbox, row[0]))
		self.db.commit()
	
    def resetMessageHashes(self, jid, postbox):
	if postbox != '':
	    self.db.cursor().execute('delete from messages where jid=? and postbox=?', (jid, postbox))
	else:
	    self.db.cursor().execute('delete from messages where jid=?', [jid])
	self.db.commit()
################################################  database ####################################################################
################################################  message composer ####################################################################
class MessageComposer:
    def listRecords(self, jid, unsequre):
        result=''
	for record in storage.getRecords(jid):
	    result += '%s %s'%(record['postbox'],record['server'])
	    if unsequre:
		result += ' %s %s'%(record['login'],record['password'])
	    result += '\n'
	return i18['user_messages']['records_list']%result;
################################################  message composer ####################################################################
########################### user handlers ##################################

def helpHandler(user,command,args,mess):
    msg  = i18['help']['header'] + ':\n'
    msg += '%s: %s\n'%(i18['help']['add']   , 'add postbox@domain.com server login password')
    msg += '%s: %s\n'%(i18['help']['remove'], 'remove postbox@domain.com')
    msg += '%s: %s\n'%(i18['help']['edit']  , 'edit postbox@domain.com server login password')
    msg += '%s: %s\n'%(i18['help']['list']  , 'list [unsequre]')
    msg += '%s: %s\n'%(i18['help']['check'] , 'check')
    msg += '%s: %s\n'%(i18['help']['reset'] , 'reset [postbox@domain.com]')
    if user.getStripped() in config['manage']['admins']:
	msg += i18['help']['admin_header'] + ':\n'
	msg += '%s: %s\n'%(i18['help']['a_add']   , 'a_add jid@domain.com postbox@domain.com server login password')
	msg += '%s: %s\n'%(i18['help']['a_remove'], 'a_remove jid@domain.com postbox@domain.com')
	msg += '%s: %s\n'%(i18['help']['a_edit']  , 'a_edit jid@domain.com postbox@domain.com server login password')
	msg += '%s: %s\n'%(i18['help']['a_check'] , 'a_cheeck [jid@domain.com]')
	msg += '%s: %s\n'%(i18['help']['a_list']  , 'a_list [jid@domain.com] [unsequre]')
	msg += '%s: %s\n'%(i18['help']['a_reset'] , 'a_reset [jid@domain.com] [postbox@domain.com]')
	msg += '%s: %s\n'%(i18['help']['a_status'], 'a_status')
	msg += '%s: %s\n'%(i18['help']['a_stop']  , 'a_quit')
    return msg
    
def addHandler(user,command,args,mess):
    data = args.split(' ')
    return bot.addRecord(user.getStripped(), data[0], data[1], data[2], string.join(data[3:]))
    
def editHandler(user,command,args,mess):
    data = args.split(' ')
    return bot.editRecord(user.getStripped(), data[0], data[1], data[2], string.join(data[3:]))
    
def removeHandler(user,command,args,mess):
    return bot.removeRecord(user.getStripped(), args)
    
def listHandler(user,command,args,mess):
    return bot.listRecords(user.getStripped(), args == 'unsequre')
    
def resetHandler(user,command,args,mess):
    return bot.resetRecord(user.getStripped(), args.strip())
    
def checkHandler(user,command,args,mess):
    return bot.checkRecords(user.getStripped())
    
####################     admin #################################
def a_addHandler(user,command,args,mess):
    if user.getStripped() in config['manage']['admins']:
	data = args.split(' ')
	return bot.addRecord(data[0], data[1], data[2], data[3], string.join(data[4:]))
    else:
	return i18['user_messages']['not_admin']%user.getStripped()
    
def a_editHandler(user,command,args,mess):
    if user.getStripped() in config['manage']['admins']:
	data = args.split(' ')
	return bot.editRecord(data[0], data[1], data[2], data[3], string.join(data[4:]))
    else:
	return i18['user_messages']['not_admin']%user.getStripped()
    
def a_removeHandler(user,command,args,mess):
    if user.getStripped() in config['manage']['admins']:
	data = args.split(' ')
	return bot.removeRecord(data[0], data[1])
    else:
	return i18['user_messages']['not_admin']%user.getStripped()
    
def a_listHandler(user,command,args,mess):
    if user.getStripped() in config['manage']['admins']:
	data = args.split(' ')
	if len(data) > 1:
	    return bot.listRecords(data[0], data[1] == 'unsequre')
	else:
	    if data[0] != '' and data[0].find('@'):
		return bot.listRecords(data[0], False)
	    else:
		message = ''
		for jid in storage.getJids():
		    message += "%s:%s\n"%(jid, bot.listRecords(jid, data[0] == 'unsequre'))
		return message
    else:
	return i18['user_messages']['not_admin']%user.getStripped()

def a_resetHandler(user,command,args,mess):
    if user.getStripped() in config['manage']['admins']:
	data = args.split(' ')
	if len(data) > 1:
	    return bot.resetRecord(data[0], data[1])
	else:
	    if len(data) > 0:
		return bot.resetRecords(data[0])
	    else:
		message = ''
		for jid in storage.getJids():
		    message += bot.resetRecords(jid)
		return message
    else:
	return i18['user_messages']['not_admin']%user.getStripped()
    
def a_checkHandler(user,command,args,mess):
    if user.getStripped() in config['manage']['admins']:
	if args != '' and args.find('@'):
	    return bot.checkRecords(args)
	else:
	    message = ''
	    for jid in storage.getJids():
		message += '%s\n'%bot.checkRecords(jid)
	    return message
    else:
	return i18['user_messages']['not_admin']%user.getStripped()
    
def a_statusHandler(user,command,args,mess):
    if user.getStripped() in config['manage']['admins']:
	return mailcheckers.statuses()
    else:
	return i18['user_messages']['not_admin']%user.getStripped()
    
def a_quitHandler(user,command,args,mess):
    if user.getStripped() in config['manage']['admins']:
	bot.quit(i18['log']['bot_command_stopping']%(bot.jid.getStripped(), user.getStripped()))
    else:
	return i18['user_messages']['not_admin']%user.getStripped()
########################### user handlers stop ###################################
################################################  bot ####################################################################
class Bot:
    def __init__(self, mailcheckers, logger, jid, password, resource):
	self.terminate = False
	self.logger = logger
	self.mailcheckers = mailcheckers
	self.jid = xmpp.JID(jid)
	self.password = password
	self.resource = resource
	self.mutex = Lock()
	self.online_users = {}

    def presenceCB(self, client_connection, msg):
	prs_type = msg.getType()
	who = msg.getFrom()
	jid_stripped = who.getStripped()
	if jid_stripped not in self.online_users:
	    self.online_users[jid_stripped] = set()
	if prs_type == "unavailable":
	    del self.online_users[jid_stripped]
	if prs_type == "subscribe":
	    self.sendPresence(who, 'subscribed')
	    self.sendPresence(who, 'subscribe')

    def messageCB(self, client_connection, mess):
	if mess.getType() != 'chat': return
	text=mess.getBody()
        user=mess.getFrom()
        if text.find(' ')+1: 
    	    command,args=text.split(' ',1)
        else: 
    	    command,args=text,''
        cmd=command.lower()
        if commands.has_key(cmd): 
    	    reply=commands[cmd](user,command,args,mess)
        else:
    	    reply=i18['user_messages']['unknown_command']%cmd
        if reply:
    	    self.sendMessage(mess.getFrom().getStripped(), reply)

    def sendMessage(self, jid_to, text):
	self.mutex.acquire()
	if jid_to in self.online_users           and config['manage']['send_to_offline_user']   == 'true' or \
	   jid_to in config['manage']['admins']  and config['manage']['send_to_offline_admin']  == 'true' or \
	   jid_to in config['manage']['loggers'] and config['manage']['send_to_offline_logger'] == 'true':
	    self.xmpp_connection.send(xmpp.Message(jid_to, text, 'chat'))
	self.mutex.release()
	
    def sendPresence(self, jid_to, p_type):
	self.mutex.acquire()
	self.xmpp_connection.send(xmpp.Presence(to=jid_to, typ=p_type))
	self.mutex.release()

    def GoOn(self):
        while not self.terminate: 
    	    self.xmpp_connection.Process(1)

    def stop(self):
	self.terminate = True
    
    def quit(self, why):
	self.logger.logToAdmins(why)
	self.mailcheckers.stop()
	self.logger.logToAdmins(i18['log']['bot_stopping']%bot.jid.getStripped())
	self.stop()
	exit(0)
    
    def run(self):
	self.xmpp_connection=xmpp.Client(self.jid.getDomain(),debug=[])
	conres=self.xmpp_connection.connect()
	if not conres:
	    print "Unable to connect to server %s!"%self.jid.getDomain()
	    sys.exit(1)
	if conres<>'tls':
	    print "Warning: unable to estabilish secure connection - TLS failed!"
	authres=self.xmpp_connection.auth(self.jid.getNode(), self.password, self.resource)
	if not authres:
	    print "Unable to authorize on %s - check login/password."%self.jid.getDomain()
	    sys.exit(1)
	if authres<>'sasl':
	    print "Warning: unable to perform SASL auth os %s. Old authentication method used!"%self.jid.getDomain()
	for i in globals().keys():
	    if i[-7:]=='Handler' and i[:-7].lower()==i[:-7]: commands[i[:-7]]=globals()[i]
	self.xmpp_connection.RegisterHandler('message' , self.messageCB )
	self.xmpp_connection.RegisterHandler('presence', self.presenceCB)
	self.xmpp_connection.sendInitPresence()
	self.logger.logToAdmins(i18['log']['bot_starting']%self.jid.getStripped())
	self.runMailCheckers()
	self.logger.logToAdmins(i18['log']['bot_started']%self.jid.getStripped())
	self.GoOn();

    def runMailCheckers(self):
	for jid in storage.getJids():
	    for record in storage.getRecords(jid):
		self.mailcheckers.add(jid, record['postbox'])
		time.sleep(int(config['mailchecker_threads_start_interval']))
	pass
    ################## commands ==================
    def addRecord(self, jid, mailbox, server, login, password):
	storage.storeRecord(jid, mailbox, server, login, password)
	mailcheckers.add(jid, mailbox)
	return i18['user_messages']['record_stored']%(mailbox, server, MessageComposer().listRecords(jid, False))
	
    def editRecord(self, jid, mailbox, server, login, password):
	storage.editRecord(jid, mailbox, server, login, password)
	return i18['user_messages']['record_changed']%(mailbox, server, MessageComposer().listRecords(jid, False))
	
    def removeRecord(self, jid, mailbox):
	storage.removeRecord(jid, mailbox)
	return i18['user_messages']['record_removed']%(mailbox, server, MessageComposer().listRecords(jid, False))
    
    def listRecords(self, jid, unsequre):
	return MessageComposer().listRecords(jid, unsequre)
	
    def resetRecord(self, jid, mailbox):
	storage.resetMessageHashes(jid, mailbox)
	return i18['user_messages']['record_cashe_reseted']%jid
	
    def resetRecords(self, jid):
	message = ''
	for record in storage.getRecords(jid):
	    message += '%s\n'%self.resetRecord(jid, mailbox)
	return message
	
    def checkRecords(self, jid):
	mailcheckers.checkNow(jid)
	return i18['user_messages']['record_check_started']%jid
################################################  bot ####################################################################

def termHSignal(signum, frame):
    bot.quit(i18['log']['bot_sig_stopping']%bot.jid.getStripped())

signal.signal(signal.SIGINT, termHSignal)
signal.signal(signal.SIGTERM, termHSignal)

json_data=open('/etc/xmpp-mailchecker-bot.conf')
config = json.load(json_data)
json_data.close()

json_data=open('/usr/local/share/xmpp-mailchecker-bot/%s'%config['lang'])
i18 = json.load(json_data)
json_data.close()

logger = XMPPLogger.CXMPPLogger(config)
storage = DBStorage()
storage.init(config['database_file'])
mailcheckers = MailCheck.CMailCheckers(i18, config, storage, logger)
bot = Bot(mailcheckers, logger, config['bot_auth']['jid'], config['bot_auth']['pwd'], config['bot_auth']['res'])

logger.setBot(bot)

bot.run()

