#!/usr/bin/env python2
# -*- coding: utf8 -*-

import sys, string, xmpp, os.path, poplib, imaplib, time, signal, os, hashlib, json, traceback, re, sqlite3
from email import parser
from email.header import decode_header
from threading import Thread, Lock

commands = {}
storage      = None
bot          = None
mailcheckers = None
config       = None
################################################  admin logger ####################################################################
class Logger:
    def log(self, text):
	if config['manage']['log_to_admins'] == 'true':
	    self.logToAdmins(text)
	self.logToLoggers(text)

    def logToAdmins(self, text):
	for admin in config['manage']['admins']:
		bot.sendMessage(admin, text)

    def logToLoggers(self, text):
	for logger in config['manage']['loggers']:
	    bot.sendMessage(logger, text)
################################################  admin logger ####################################################################
################################################  mail checker ####################################################################
class CheckError(Exception):
    def __init__(self, value):
	self.value = value
    def __str__(self):
	return repr(self.value)
	
class MailChecker(Thread):
    def __init__(self, jid, interval):
	Thread.__init__(self)
	self.jid = jid
	self.interval = interval
	self.terminate = False
	self.check_now = False
	self.imap_box_filter = re.compile('(%s)'%'|'.join(config['imap']['skip_folders']))
	self.status = i18['mailchecker_status']['sleep']

    def decodeText(self, header_text):
	headers = decode_header(header_text)
	formatted = u''
	for text, charset in headers:
	    if text:
		text_part = unicode(text, charset or "utf-8")
		for m in re.findall(r'(=\?.+?\?=)', text_part):
		    hpart = decode_header(m)
		    text_part = text_part.replace(m, unicode(hpart[0][0], hpart[0][1] or "utf-8"))
		formatted += text_part
	for repl_from, repl_to in config['headers_text_replaces']:
	    formatted = re.sub(repl_from, repl_to, formatted, 0)
	return formatted

    def checkPop(self, record):
	result = ''
	messages_count = 0
	Logger().log(i18['log']['try_check_mail']%('POP3', record['server'], self.jid))
	connection = None
	self.status = i18['mailchecker_status']['connect']%('POP3', record['server'])
	try:
	    connection = poplib.POP3_SSL(record['server'])
	except:
	    Logger().log(i18['log']['proto_ssl_err']%('POP3', traceback.format_exc()))
	    try:
		connection = poplib.POP3(record['server'])
	    except:
		Logger().log(i18['log']['proto_err']%('POP3', traceback.format_exc()))
		raise CheckError(i18['log']['proto_conn_failed']%('POP3', record['server'], traceback.format_exc()))
	self.status = i18['mailchecker_status']['check']%('POP3', record['server'])
	connection.user(record['login'])
	connection.pass_(record['password'])
	
	messages = [connection.retr(i) for i in range(connection.stat()[0], 0, -1)]
	messages = ["\n".join(mssg[1]) for mssg in messages]
	messages = [parser.Parser().parsestr(mssg, True) for mssg in messages]

	hashes = list()
	for message in messages:
	    message_hash = self.buildMessageHash(message)
	    hashes.append(message_hash)
	    if not storage.checkMessageHashExists(self.jid, record['postbox'], message_hash):
		result += i18['user_messages']['new_post_mail']%(self.decodeText(message['From']),self.decodeText(message['Subject']))
		messages_count += 1
	
	self.status = i18['mailchecker_status']['disconnect']%('POP3', record['server'])
	connection.quit()
	self.status = i18['mailchecker_status']['cache_clean']%(record['postbox'])
	storage.cleanMessageHashes(self.jid, record['postbox'], hashes)
	
	Logger().log(i18['log']['check_done']%('POP3', record['server'], self.jid))
	self.status = i18['mailchecker_status']['sleep']
	return {"result": result, "msg_count": messages_count}
	
    def checkImap(self, record):
	result = ''
	messages_count = 0
	Logger().log(i18['log']['try_check_mail']%('IMAP4', record['server'], self.jid))
	connection = None
	self.status = i18['mailchecker_status']['connect']%('IMAP4', record['server'])
	try:
	    connection = imaplib.IMAP4_SSL(record['server'])
	except:
	    Logger().log(i18['log']['proto_ssl_err']%('IMAP4', traceback.format_exc()))
	    try:
		connection = imaplib.IMAP4(record['server'])
	    except:
		Logger().log(i18['log']['proto_err']%('IMAP4', traceback.format_exc()))
		raise CheckError(i18['log']['proto_conn_failed']%('IMAP4', record['server'], traceback.format_exc()))
	self.status = i18['mailchecker_status']['check']%('IMAP4', record['server'])
	connection.login(record['login'], record['password'])
	
	hashes = list()
	
	for directory in connection.list()[1]:
	    matches = re.finditer(r'"(.+?)"', directory)
	    results = [match.group(1) for match in matches]
	    directory = results[1]
	    
	    if not self.imap_box_filter.match(directory): 
		connection.select(directory, True)
		typ, data = connection.search(None, 'UNSEEN')
		if data[0] != '':
		    messages = [connection.fetch(i, '(BODY[HEADER.FIELDS (SUBJECT FROM)])')[1][0][1] for i in data[0].split(' ')]
		    messages = [parser.Parser().parsestr(mssg, True) for mssg in messages]

		    for message in messages:
			if message['From']:
			    message_hash = self.buildMessageHash(message)
			    hashes.append(message_hash)
			    if not storage.checkMessageHashExists(self.jid, record['postbox'], message_hash):
				result += i18['user_messages']['new_post_mail']%(self.decodeText(message['From']),self.decodeText(message['Subject']))
				messages_count += 1

	self.status = i18['mailchecker_status']['cache_clean']%(record['postbox'])
	storage.cleanMessageHashes(self.jid, record['postbox'], hashes)
	self.status = i18['mailchecker_status']['disconnect']%('IMAP4', record['server'])
	connection.close()
	connection.logout()
	Logger().log(i18['log']['check_done']%('IMAP4', record['server'], self.jid))
	self.status = i18['mailchecker_status']['sleep']
	return {"result": result, "msg_count": messages_count}
	
    def buildMessageHash(self, message):
	return hashlib.sha224(message['From']+message['Subject']).hexdigest()
	
    def checkMail(self):
	result = ''
	for record in storage.getRecords(self.jid):
	    try:
		boxResult = self.checkImap(record)
		if int(boxResult['msg_count']) > 0:
		    result += i18['user_messages']['new_post']%(record['postbox'], boxResult['result'], boxResult['msg_count'])
	    except CheckError as e_imap:
		try:
		    boxResult = self.checkPop(record)
		    if int(boxResult['msg_count']) > 0:
			result += i18['user_messages']['new_post']%(record['postbox'], boxResult['result'], boxResult['msg_count'])
		except CheckError as e_pop:
		    result += "%s\n%s"%(e_imap.value, e_pop.value)
	return result

    def GoOn(self):
	while not self.terminate:
	    result = self.checkMail()
	    if result != '':
		bot.sendMessage(self.jid, result)
	    for x in range(0, self.interval):
		time.sleep(1)
		if self.terminate or self.check_now:
		    self.check_now = False
		    break

    def run(self):
	Logger().log(i18['log']['mailchecker_thread_started']%self.jid)
	self.GoOn()

    def checkNow(self):
	self.check_now = True
	
    def stop(self):
	self.terminate = True
################################################  mail checker ####################################################################
################################################  mail checkers ####################################################################
class MailCheckers:
    def __init__(self):
	self.checkers = []
	
    def add(self, jid):
	checker = None
	for ch in self.checkers:
	    if ch['jid'] == jid:
		checker = ch['ch']
		break
	if not checker:
	    checker = MailChecker(jid, int(config['mail_check_interval']))
	    self.checkers.append({ 'jid': jid, 'ch': checker })
	    checker.start()
	
    def checkNow(self, jid):
	for checker in self.checkers:
	    if checker['jid'] == jid:
		checker['ch'].checkNow()

    def statuses(self):
	st = '\n'
	for checker in self.checkers:
	    st += '%s: %s\n'%(checker['jid'], checker['ch'].status)
	return st

    def stop(self):
	for checker in self.checkers:
	    checker['ch'].stop()
	    checker['ch'].join()
################################################  mail checkers ####################################################################
################################################  database ####################################################################
class DBStorage(object):

    def init(self, db_file):
	db_exists = os.path.exists(db_file)
	self.db = sqlite3.connect(db_file, check_same_thread = False)
	if not db_exists:
	    self.db.cursor().execute('CREATE TABLE records (jid VARCHAR(256), postbox VARCHAR(256), server VARCHAR(256), login VARCHAR(256), password VARCHAR(256))')
	    self.db.cursor().execute('CREATE TABLE messages (jid VARCHAR(256), postbox VARCHAR(256), message_hash VARCHAR(64))')
	    self.db.cursor().execute('create index records_index_jid on records (jid)')
	    self.db.cursor().execute('create index records_index on records (jid, postbox)')
	    self.db.cursor().execute('create index messages_index_jid on messages (jid)')
	    self.db.cursor().execute('create index messages_index on messages (jid, postbox)')
	    self.db.commit()
	
    def getRecord(self, jid, postbox):
	q = self.db.cursor()
	q.execute('select server, login, password from records where jid=? and postbox=?', (jid, postbox))
	for row in q:
	    return {'jid': jid, 'postbox': postbox, 'server': row[0], 'login': row[1], 'password': row[2]}
	    
    def getRecords(self, jid):
	q = self.db.cursor()
	q.execute('select postbox, server, login, password from records where jid=?', [jid])
	result=list()
	for row in q:
	    result.append({'jid': jid, 'postbox': row[0], 'server': row[1], 'login': row[2], 'password': row[3]})
	return result

    def getJids(self):
	q = self.db.cursor()
	q.execute('select distinct jid from records')
	result=list()
	for row in q:
	    result.append(row[0])
	return result

    def storeRecord(self, jid, postbox, server, login, password):
	self.db.cursor().execute('INSERT INTO records VALUES (?, ?, ?, ?, ?)', (jid, postbox, server, login, password))
	self.db.commit()
	
    def editRecord(self, jid, postbox, server, login, password):
	self.db.cursor().execute('update records set server=?, login=?, password=? wherejid=? and postbox=?)', (server, login, password, jid, postbox))
	self.db.commit()
	
    def removeRecord(self, jid, postbox):
	self.db.cursor().execute('delete from records where jid=? and postbox=?', (jid, postbox))
	self.db.commit()
	self.resetMessageHashes(jid, postbox)
	
    def checkMessageHashExists(self, jid, postbox, message_hash):
	q = self.db.cursor()
	q.execute('select count(*) from messages where jid=? and postbox=? and message_hash=?', (jid, postbox, message_hash))
	result = False
	for row in q:
	    if int(row[0]) > 0:
		result = True
	    else:
		self.db.cursor().execute('INSERT INTO messages VALUES (?, ?, ?)', (jid, postbox, message_hash))
		self.db.commit()
	    break
	return result

    def cleanMessageHashes(self, jid, postbox, hashes):
	q = self.db.cursor()
	q.execute('select message_hash from messages where jid=? and postbox=?', (jid, postbox))
	for row in q:
	    if row[0] not in hashes:
		self.db.cursor().execute('delete from messages where jid=? and postbox=? and message_hash=?', (jid, postbox, row[0]))
		self.db.commit()
	
    def resetMessageHashes(self, jid, postbox):
	if postbox != '':
	    self.db.cursor().execute('delete from messages where jid=? and postbox=?', (jid, postbox))
	else:
	    self.db.cursor().execute('delete from messages where jid=?', [jid])
	self.db.commit()
################################################  database ####################################################################
################################################  message composer ####################################################################
class MessageComposer:
    def listRecords(self, jid, unsequre):
        result=''
	for record in storage.getRecords(jid):
	    result += '%s %s'%(record['postbox'],record['server'])
	    if unsequre:
		result += ' %s %s'%(record['login'],record['password'])
	    result += '\n'
	return i18['user_messages']['records_list']%result;
################################################  message composer ####################################################################
########################### user handlers ##################################
class HWorker:
    def addRecord(self, jid, mailbox, server, login, password):
	storage.storeRecord(jid, mailbox, server, login, password)
	mailcheckers.add(jid)
	return i18['user_messages']['record_stored']%(mailbox, server, MessageComposer().listRecords(jid, False))
	
    def editRecord(self, jid, mailbox, server, login, password):
	storage.editRecord(jid, mailbox, server, login, password)
	return i18['user_messages']['record_changed']%(mailbox, server, MessageComposer().listRecords(jid, False))
	
    def removeRecord(self, jid, mailbox):
	storage.removeRecord(jid, mailbox)
	return i18['user_messages']['record_removed']%(mailbox, server, MessageComposer().listRecords(jid, False))
    
    def listRecords(self, jid, unsequre):
	return MessageComposer().listRecords(jid, unsequre)
	
    def resetRecord(self, jid, mailbox):
	storage.resetMessageHashes(jid, mailbox)
	return i18['user_messages']['record_cashe_reseted']%jid
	
    def resetRecords(self, jid):
	message = ''
	for record in storage.getRecords(jid):
	    message += '%s\n'%self.resetRecord(jid, mailbox)
	return message
	
    def checkRecords(self, jid):
	mailcheckers.checkNow(jid)
	return i18['user_messages']['record_check_started']%jid
	
def helpHandler(user,command,args,mess):
    msg  = i18['help']['header'] + ':\n'
    msg += '%s: %s\n'%(i18['help']['add']   , 'add postbox@domain.com server login password')
    msg += '%s: %s\n'%(i18['help']['remove'], 'remove postbox@domain.com')
    msg += '%s: %s\n'%(i18['help']['edit']  , 'edit postbox@domain.com server login password')
    msg += '%s: %s\n'%(i18['help']['list']  , 'list [unsequre]')
    msg += '%s: %s\n'%(i18['help']['check'] , 'check')
    msg += '%s: %s\n'%(i18['help']['reset'] , 'reset [postbox@domain.com]')
    if user.getStripped() in config['manage']['admins']:
	msg += i18['help']['admin_header'] + ':\n'
	msg += '%s: %s\n'%(i18['help']['a_add']   , 'a_add jid@domain.com postbox@domain.com server login password')
	msg += '%s: %s\n'%(i18['help']['a_remove'], 'a_remove jid@domain.com postbox@domain.com')
	msg += '%s: %s\n'%(i18['help']['a_edit']  , 'a_edit jid@domain.com postbox@domain.com server login password')
	msg += '%s: %s\n'%(i18['help']['a_check'] , 'a_cheeck [jid@domain.com]')
	msg += '%s: %s\n'%(i18['help']['a_list']  , 'a_list [jid@domain.com] [unsequre]')
	msg += '%s: %s\n'%(i18['help']['a_reset'] , 'a_reset [jid@domain.com] [postbox@domain.com]')
	msg += '%s: %s\n'%(i18['help']['a_status'], 'a_status')
	msg += '%s: %s\n'%(i18['help']['a_stop']  , 'a_quit')
    return msg
    
def addHandler(user,command,args,mess):
    data = args.split(' ')
    return HWorker().addRecord(user.getStripped(), data[0], data[1], data[2], string.join(data[3:]))
    
def editHandler(user,command,args,mess):
    data = args.split(' ')
    return HWorker().editRecord(user.getStripped(), data[0], data[1], data[2], string.join(data[3:]))
    
def removeHandler(user,command,args,mess):
    return HWorker().removeRecord(user.getStripped(), args)
    
def listHandler(user,command,args,mess):
    return HWorker().listRecords(user.getStripped(), args == 'unsequre')
    
def resetHandler(user,command,args,mess):
    return HWorker().resetRecord(user.getStripped(), args.strip())
    
def checkHandler(user,command,args,mess):
    return HWorker().checkRecords(user.getStripped())
    
####################     admin #################################
def a_addHandler(user,command,args,mess):
    if user.getStripped() in config['manage']['admins']:
	data = args.split(' ')
	return HWorker().addRecord(data[0], data[1], data[2], data[3], string.join(data[4:]))
    else:
	return i18['user_messages']['not_admin']%user.getStripped()
    
def a_editHandler(user,command,args,mess):
    if user.getStripped() in config['manage']['admins']:
	data = args.split(' ')
	return HWorker().editRecord(data[0], data[1], data[2], data[3], string.join(data[4:]))
    else:
	return i18['user_messages']['not_admin']%user.getStripped()
    
def a_removeHandler(user,command,args,mess):
    if user.getStripped() in config['manage']['admins']:
	data = args.split(' ')
	return HWorker().removeRecord(data[0], data[1])
    else:
	return i18['user_messages']['not_admin']%user.getStripped()
    
def a_listHandler(user,command,args,mess):
    if user.getStripped() in config['manage']['admins']:
	data = args.split(' ')
	if len(data) > 1:
	    return HWorker().listRecords(data[0], data[1] == 'unsequre')
	else:
	    if data[0] != '' and data[0].find('@'):
		return HWorker().listRecords(data[0], False)
	    else:
		message = ''
		for jid in storage.getJids():
		    message += "%s:%s\n"%(jid, HWorker().listRecords(jid, data[0] == 'unsequre'))
		return message
    else:
	return i18['user_messages']['not_admin']%user.getStripped()

def a_resetHandler(user,command,args,mess):
    if user.getStripped() in config['manage']['admins']:
	data = args.split(' ')
	if len(data) > 1:
	    return HWorker().resetRecord(data[0], data[1])
	else:
	    if len(data) > 0:
		return HWorker().resetRecords(data[0])
	    else:
		message = ''
		for jid in storage.getJids():
		    message += HWorker().resetRecords(jid)
		return message
    else:
	return i18['user_messages']['not_admin']%user.getStripped()
    
def a_checkHandler(user,command,args,mess):
    if user.getStripped() in config['manage']['admins']:
	if args != '' and args.find('@'):
	    return HWorker().checkRecords(args)
	else:
	    message = ''
	    for jid in storage.getJids():
		message += '%s\n'%HWorker().checkRecords(jid)
	    return message
    else:
	return i18['user_messages']['not_admin']%user.getStripped()
    
def a_statusHandler(user,command,args,mess):
    if user.getStripped() in config['manage']['admins']:
	return mailcheckers.statuses()
    else:
	return i18['user_messages']['not_admin']%user.getStripped()
    
def a_quitHandler(user,command,args,mess):
    if user.getStripped() in config['manage']['admins']:
	Logger().logToAdmins(i18['log']['bot_command_stopping']%(bot.jid.getStripped(), user.getStripped()))
	mailcheckers.stop()
	Logger().logToAdmins(i18['log']['bot_stopping']%bot.jid.getStripped())
	bot.stop()
	exit(0)
    else:
	return i18['user_messages']['not_admin']%user.getStripped()
########################### user handlers stop ###################################
################################################  bot ####################################################################
class Bot:
    def __init__(self, jid, password, resource):
	self.terminate = False
	self.jid = xmpp.JID(jid)
	self.password = password
	self.resource = resource
	self.mutex = Lock()
	self.online_users = {}

    def presenceCB(self, client_connection, msg):
	prs_type = msg.getType()
	who = msg.getFrom()
	jid_stripped = who.getStripped()
	if jid_stripped not in self.online_users:
	    self.online_users[jid_stripped] = set()
	if prs_type == "unavailable":
	    del self.online_users[jid_stripped]
	if prs_type == "subscribe":
	    self.sendPresence(who, 'subscribed')
	    self.sendPresence(who, 'subscribe')

    def messageCB(self, client_connection, mess):
	if mess.getType() != 'chat': return
	text=mess.getBody()
        user=mess.getFrom()
        if text.find(' ')+1: 
    	    command,args=text.split(' ',1)
        else: 
    	    command,args=text,''
        cmd=command.lower()
        if commands.has_key(cmd): 
    	    reply=commands[cmd](user,command,args,mess)
        else:
    	    reply=i18['user_messages']['unknown_command']%cmd
        if reply:
    	    self.sendMessage(mess.getFrom().getStripped(), reply)

    def sendMessage(self, jid_to, text):
	self.mutex.acquire()
	if jid_to in self.online_users           and config['manage']['send_to_offline_user']   == 'true' or \
	   jid_to in config['manage']['admins']  and config['manage']['send_to_offline_admin']  == 'true' or \
	   jid_to in config['manage']['loggers'] and config['manage']['send_to_offline_logger'] == 'true':
	    self.xmpp_connection.send(xmpp.Message(jid_to, text, 'chat'))
	self.mutex.release()
	
    def sendPresence(self, jid_to, p_type):
	self.mutex.acquire()
	self.xmpp_connection.send(xmpp.Presence(to=jid_to, typ=p_type))
	self.mutex.release()

    def GoOn(self):
        while not self.terminate: 
    	    self.xmpp_connection.Process(1)

    def stop(self):
	self.terminate = True
    
    def run(self):
	self.xmpp_connection=xmpp.Client(self.jid.getDomain(),debug=[])
	conres=self.xmpp_connection.connect()
	if not conres:
	    print "Unable to connect to server %s!"%self.jid.getDomain()
	    sys.exit(1)
	if conres<>'tls':
	    print "Warning: unable to estabilish secure connection - TLS failed!"
	authres=self.xmpp_connection.auth(self.jid.getNode(), self.password, self.resource)
	if not authres:
	    print "Unable to authorize on %s - check login/password."%self.jid.getDomain()
	    sys.exit(1)
	if authres<>'sasl':
	    print "Warning: unable to perform SASL auth os %s. Old authentication method used!"%self.jid.getDomain()
	for i in globals().keys():
	    if i[-7:]=='Handler' and i[:-7].lower()==i[:-7]: commands[i[:-7]]=globals()[i]
	self.xmpp_connection.RegisterHandler('message' , self.messageCB )
	self.xmpp_connection.RegisterHandler('presence', self.presenceCB)
	self.xmpp_connection.sendInitPresence()
	Logger().logToAdmins(i18['log']['bot_starting']%self.jid.getStripped())
	self.runMailCheckers()
	Logger().logToAdmins(i18['log']['bot_started']%self.jid.getStripped())
	self.GoOn();

    def runMailCheckers(self):
	for jid in storage.getJids():
	    mailcheckers.add(jid)
	    time.sleep(int(config['mailchecker_threads_start_interval']))
	pass
################################################  bot ####################################################################

def termHSignal(signum, frame):
    Logger().logToAdmins(i18['log']['bot_sig_stopping']%bot.jid.getStripped())
    mailcheckers.stop()
    Logger().logToAdmins(i18['log']['bot_stopping']%bot.jid.getStripped())
    bot.stop()
    exit(0)

signal.signal(signal.SIGINT, termHSignal)
signal.signal(signal.SIGTERM, termHSignal)

json_data=open('/etc/xmpp-mailchecker-bot.conf')
config = json.load(json_data)
json_data.close()

json_data=open('/usr/local/share/xmpp-mailchecker-bot/%s'%config['lang'])
i18 = json.load(json_data)
json_data.close()

storage = DBStorage()
storage.init(config['database_file'])
mailcheckers = MailCheckers()
bot = Bot(config['bot_auth']['jid'], config['bot_auth']['pwd'], config['bot_auth']['res'])
bot.run()

